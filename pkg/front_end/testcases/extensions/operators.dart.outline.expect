library;
import self as self;
import "dart:core" as core;

class Complex extends core::Object /*hasConstConstructor*/  {
  final field core::double* real;
  final field core::double* imaginary;
  const constructor •(core::double* real, core::double* imaginary) → self::Complex*
    : self::Complex::real = real, self::Complex::imaginary = imaginary, super core::Object::•()
    ;
  method add(self::Complex* other) → self::Complex*
    ;
  method sub(self::Complex* other) → self::Complex*
    ;
  method negate() → self::Complex*
    ;
  get hashCode() → core::int*
    ;
  operator ==(core::Object* other) → core::bool*
    ;
  method toString() → core::String*
    ;
  abstract member-signature get _identityHashCode() → core::int*;
  abstract member-signature method _instanceOf(dynamic instantiatorTypeArguments, dynamic functionTypeArguments, dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOf(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfTrue(dynamic type) → core::bool*;
  abstract member-signature method _simpleInstanceOfFalse(dynamic type) → core::bool*;
  abstract member-signature method noSuchMethod(core::Invocation* invocation) → dynamic;
  abstract member-signature get runtimeType() → core::Type*;
}
extension Operators on self::Complex* {
  operator + = self::Operators|+;
  operator - = self::Operators|-;
  operator unary- = self::Operators|unary-;
}
static method Operators|+(final self::Complex* #this, self::Complex* other) → self::Complex*
  ;
static method Operators|-(final self::Complex* #this, self::Complex* other) → self::Complex*
  ;
static method Operators|unary-(final self::Complex* #this) → self::Complex*
  ;
static method main() → dynamic
  ;
static method implicit() → dynamic
  ;
static method explicit() → dynamic
  ;
static method errors(self::Complex* c) → void
  ;
static method expect(dynamic expected, dynamic actual) → dynamic
  ;
